
My program is a side-scrolling shooter game
based on an underwater theme, with increasing
difficulty as the user nears the end of the game.
The player is given a basic ability (blue bubbles),
as well as health and time. 
As the player progresses throughout the game, 
the difficulty increases, and the density and 
strength of the obstacles (fish; two types)
increases. As they are able to hit more, the user
is able to increase their health and ability 
levels as well as time. 
To solve this issue, I had to manage many issues
such as the constant movement of the obstacles,
the bullets/bubbles, etc. Mostly, the problem 
of the physics of the moving user was the most difficult.
Rather than allowing the user to control the player
by key presses, I made velocities that would affect
the position of the player as the time went by,
that would be affected by the key presses. 
I made classes for the user, fish, bubbles, and the
corals so that they could change in property and 
be randomized.
My project was similar in other games such 
as super mario bros and flappy bird in some aspects,
but had a specific design- so that there would be a
set path and goal, and increasing "levels" that 
are based on the path and location of the user,
but like how the pipes are randomized in location in
flappy bird, the location of the incoming predators
are randomized, as well as the design of the fractals.
As the player nears the end of the game, the design 
darkens and the amount of infected fish increase
in comparison to the healthy fish. The bars at the 
bottom of the screen allow the user to see
how much health, time, and ability points they have
in a streamlined design that is easier to understand
than just numbers. The user is also able to see
their progress in the game through the bar/map
in the center-bottom of the window, which is marked
by orange lines to indicate the changing phases.
What was good about flappy bird was that it saved
space by randomizing the pipes, but it did not have
a specific end goal, which made it too simple. Also, 
the user was not able to scroll backwards or have a
specific location that affected the difficulty of the
game. However, this is implemented in super mario 
bros, although it is limited by how the difficulty
increases are more hardcoded. My game 
combined these two aspects on a spectrum. 